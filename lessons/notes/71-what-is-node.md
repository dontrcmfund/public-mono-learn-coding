# What is Node.js? (first principles)

Goal: understand what Node.js is, why it was created, and why it changed JavaScript learning paths.

Why do we care?
- Node runs JavaScript outside the browser
- It enables scripts, tooling, and backend servers in one language
- It reduces context switching between front-end and back-end work

Why this matters to you (past, present, future)
- Past: if browser-only JS felt limiting, Node expands what JS can do
- Present: you can automate local tasks and run lesson scripts easily
- Future: Node is a common runtime for APIs, CLIs, and build tooling

First principles
- A runtime executes language code
- Browsers are one JavaScript runtime
- Node is another runtime with file system and OS APIs

Short history (why this exists)
- JavaScript began in browsers for interactive pages
- In 2009, Node brought JS to server-side and tool-side development
- Its event-driven, non-blocking model made it useful for IO-heavy workloads

Etymology
- `Node` refers to a participating unit in a network/system
- `runtime` means the environment where your code actually executes

What to do (slow and simple)
- Run a Node lesson file and inspect output
- Notice that no browser is required

If all you remember is one thing
- Node.js is JavaScript running in a server/tool runtime instead of a browser

Checkpoint
- If you can explain one thing Node can do that browser JS cannot, you are ready to move on

Reflection
- Which personal task could become a Node script?
- How does one-language workflow lower learning friction?
